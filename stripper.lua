---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ikygoose.
--- DateTime: 12/29/2020 6:13 PM
---

os.loadAPI("moveAPI.lua")

MAX_COST = 50

tArgs = {...}
depth = tonumber(tArgs[1])
width = tonumber(tArgs[2])
blackListFile = tArgs[3]

blackList = {}

function collisionCallBack(direction)
    if direction == moveAPI.UP then
        turtle.attackUp()
    elseif direction == moveAPI.DOWN then
        turtle.attackDown()
    else
        turtle.attack()
    end
end

--- initialize the ore table
function initBlackList( blackListFile )
    fileHandle = fs.open( blackListFile, "r")
    text = fileHandle.readAll()
    data = textutils.unserialize( text )
    fileHandle.close()
    blackList = data
end

--- check if the block tpye is in the ore table
function isOre( blockType )
    ore = true
    for i, block in ipairs(blackList) do
        if blockType == block then
            ore = false
        end
    end
    return ore
end

--- get the cords of the block in a given direction of the turtle
function cordsOf( direction )

    x = moveAPI.getOrientation().x
    y = moveAPI.getOrientation().y
    z = moveAPI.getOrientation().z

    dir = moveAPI.getOrientation().direction

    if direction == moveAPI.FORWARD then
        if dir == moveAPI.NORTH then
            z = z - 1
        elseif dir == moveAPI.SOUTH then
            z = z + 1
        elseif dir == moveAPI.EAST then
            x = x + 1
        elseif dir == moveAPI.WEST then
            x = x - 1
        end
    elseif direction == moveAPI.UP then
        y = y + 1
    elseif direction == moveAPI.DOWN then
        y = y - 1
    end
    return {x, y, z}
end

function digShaft( maxCost )
    maxCost = maxCost or MAX_COST

    shaftX = moveAPI.getOrientation().x
    shaftY = moveAPI.getOrientation().y
    shaftZ = moveAPI.getOrientation().z

    dir = moveAPI.getOrientation().direction

    digging = true
    while digging do
        if turtle.detectDown() and not turtle.digDown() then
            digging = false
        end
        if not moveAPI.move(moveAPI.DOWN, 1) then
            digging = false
        end
        mineX = moveAPI.getOrientation().x
        mineY = moveAPI.getOrientation().y
        mineZ = moveAPI.getOrientation().z
        mine()
        moveAPI.pathTo( mineX, mineY, mineZ, maxCost, nil, collisionCallBack )
    end

    moveAPI.moveTo( shaftX, shaftY, shaftZ, {moveAPI.Y, moveAPI.X, moveAPI.Z} )

end

function mine( maxCost )
    maxCost = maxCost or MAX_COST

    blocks = {{moveAPI.getOrientation().x,moveAPI.getOrientation().y,moveAPI.getOrientation().z}}

    while #blocks > 0 do
        ore = blocks[1]
        table.remove(blocks,1)
        moveAPI.pathTo( ore[1], ore[2], ore[3], maxCost, nil, collisionCallBack )

        isUp, up = turtle.inspectUp()
        isDown, down = turtle.inspectDown()

        if isUp and isOre(up.name) then
            if turtle.digUp() then
                table.insert(blocks, cordsOf( moveAPI.UP ) )
            end
        end

        if isDown and isOre(down.name) then
            if turtle.digDown() then
                table.insert(blocks, cordsOf( moveAPI.DOWN ) )
            end
        end

        for i = 0, 3 do
            isFront, front = turtle.inspect()
            if isFront and isOre(front.name) then
                if turtle.dig() then
                    table.insert(blocks, cordsOf( moveAPI.FORWARD ) )
                end
            end
            moveAPI.turn( moveAPI.RIGHT )
        end

    end
end

function findShafts( width, depth )

    x = moveAPI.getOrientation().x
    y = moveAPI.getOrientation().y
    z = moveAPI.getOrientation().z

    shafts = {}
    offsets = {0,2,4,1,3}
    i = 0
    j = 0
    while i < depth do
        j = offsets[(i % 5) + 1]
        while j < width do
            table.insert(shafts, {x+j, y, z-i} )
            j = j + 5
        end
        i = i + 1
    end
    return shafts
end

initBlackList(blackListFile)

mineShaftX = moveAPI.getOrientation().x
mineShaftY = moveAPI.getOrientation().y
mineShaftZ = moveAPI.getOrientation().z

shafts = findShafts(width, depth)

for i, shaft in ipairs(shafts) do
    moveAPI.pathTo( shaft[1], shaft[2], shaft[3], MAX_COST, nil, collisionCallBack )
    digShaft()
    moveAPI.pathTo( mineShaftX, mineShaftY, mineShaftZ, MAX_COST, nil, collisionCallBack )

    for i = 1,16 do
        turtle.select(i)
        turtle.dropUp()
    end
end
