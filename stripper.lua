---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ikygoose.
--- DateTime: 12/29/2020 6:13 PM
---

os.loadAPI("moveAPI.lua")

MAX_COST = 50
LAST_SLOT = 16

tArgs = {...}
depth = tonumber(tArgs[1])
width = tonumber(tArgs[2])
blackListFile = tArgs[3]

blackList = {}

function collisionCallBack(direction)
    if direction == moveAPI.UP then
        turtle.attackUp()
    elseif direction == moveAPI.DOWN then
        turtle.attackDown()
    else
        turtle.attack()
    end
end

--- initialize the ore table
function initBlackList( blackListFile )
    fileHandle = fs.open( blackListFile, "r")
    text = fileHandle.readAll()
    data = textutils.unserialize( text )
    fileHandle.close()
    blackList = data
end

--- check if the block tpye is in the ore table
function isOre( blockType )
    ore = true
    for i, block in ipairs(blackList) do
        if blockType == block then
            ore = false
        end
    end
    return ore
end

--- get the cords of the block in a given direction of the turtle
function cordsOf( direction )

    x = moveAPI.getOrientation().x
    y = moveAPI.getOrientation().y
    z = moveAPI.getOrientation().z

    dir = moveAPI.getOrientation().direction

    if direction == moveAPI.FORWARD then
        if dir == moveAPI.NORTH then
            z = z - 1
        elseif dir == moveAPI.SOUTH then
            z = z + 1
        elseif dir == moveAPI.EAST then
            x = x + 1
        elseif dir == moveAPI.WEST then
            x = x - 1
        end
    elseif direction == moveAPI.UP then
        y = y + 1
    elseif direction == moveAPI.DOWN then
        y = y - 1
    end
    return {x, y, z}
end

--- handles the drop off logic, return to the progress depth of the mine
function dropOff( storageX, storageY, storageZ, shaftX, shaftY, shaftZ, mineX, mineY, mineZ, maxCost )
    moveAPI.pathTo( mineX, mineY, mineZ, maxCost, nil, collisionCallBack)
    moveAPI.moveTo( shaftX, shaftY, shaftZ, {moveAPI.Y, moveAPI.X, moveAPI.Z} )
    moveAPI.pathTo( storageX, storageY, storageZ, maxCost, nil, collisionCallBack)
    for i = 1,16 do
        turtle.select(i)
        turtle.dropUp()
    end
    turtle.select(1)
    moveAPI.pathTo( shaftX, shaftY, shaftZ, maxCost, nil, collisionCallBack)
    moveAPI.moveTo( mineX, mineY, mineZ, {moveAPI.Y, moveAPI.X, moveAPI.Z} )
end

--- digs a mineshaft to bedrock from the current location
function digShaft( storageX, storageY, storageZ, maxCost )
    maxCost = maxCost or MAX_COST

    local shaftX = moveAPI.getOrientation().x
    local shaftY = moveAPI.getOrientation().y
    local shaftZ = moveAPI.getOrientation().z

    local dir = moveAPI.getOrientation().direction

    local digging = true
    while digging do
        if turtle.detectDown() and not turtle.digDown() then
            digging = false
        end
        if not moveAPI.move(moveAPI.DOWN, 1) then
            digging = false
        end
        local mineX = moveAPI.getOrientation().x
        local mineY = moveAPI.getOrientation().y
        local mineZ = moveAPI.getOrientation().z

        mine( storageX, storageY, storageZ, shaftX, shaftY, shaftZ, mineX, mineY, mineZ, maxCost )

        moveAPI.pathTo( mineX, mineY, mineZ, maxCost, nil, collisionCallBack )
    end

    moveAPI.moveTo( shaftX, shaftY, shaftZ, {moveAPI.Y, moveAPI.X, moveAPI.Z} )

end

function mine( storageX, storageY, storageZ, shaftX, shaftY, shaftZ, mineX, mineY, mineZ, maxCost )
    maxCost = maxCost or MAX_COST

    local blocks = {{moveAPI.getOrientation().x,moveAPI.getOrientation().y,moveAPI.getOrientation().z}}

    while #blocks > 0 do
        ore = blocks[1]
        table.remove(blocks,1)
        moveAPI.pathTo( ore[1], ore[2], ore[3], maxCost, nil, collisionCallBack )

        isUp, up = turtle.inspectUp()
        isDown, down = turtle.inspectDown()

        if isUp and isOre(up.name) then
            if turtle.digUp() then
                table.insert(blocks, cordsOf( moveAPI.UP ) )
                if turtle.getItemCount(LAST_SLOT) > 0 then
                    dropOff(storageX, storageY, storageZ, shaftX, shaftY, shaftZ, mineX, mineY, mineZ, maxCost )
                end
            end
        end

        if isDown and isOre(down.name) then
            if turtle.digDown() then
                table.insert(blocks, cordsOf( moveAPI.DOWN ) )
                if turtle.getItemCount(LAST_SLOT) > 0 then
                    dropOff(storageX, storageY, storageZ, shaftX, shaftY, shaftZ, mineX, mineY, mineZ, maxCost )
                end
            end
        end

        for i = 0, 3 do
            isFront, front = turtle.inspect()
            if isFront and isOre(front.name) then
                if turtle.dig() then
                    table.insert(blocks, cordsOf( moveAPI.FORWARD ) )
                    if turtle.getItemCount(LAST_SLOT) > 0 then
                        local dir = moveAPI.getOrientation().direction
                        dropOff(storageX, storageY, storageZ, shaftX, shaftY, shaftZ, mineX, mineY, mineZ, maxCost )
                        moveAPI.turn(dir)
                    end
                end
            end
            moveAPI.turn( moveAPI.RIGHT )
        end

    end
end

function findShafts( width, depth )

    local x = moveAPI.getOrientation().x
    local y = moveAPI.getOrientation().y
    local z = moveAPI.getOrientation().z

    local shafts = {}
    local offsets = {0,2,4,1,3}
    local i = 0
    local j = 0
    while i < depth do
        j = offsets[(i % 5) + 1]
        while j < width do
            table.insert(shafts, {x+j, y, z-i} )
            j = j + 5
        end
        i = i + 1
    end
    return shafts
end

initBlackList(blackListFile)

local mineShaftX = moveAPI.getOrientation().x
local mineShaftY = moveAPI.getOrientation().y
local mineShaftZ = moveAPI.getOrientation().z

local shafts = findShafts(width, depth)

for i, shaft in ipairs(shafts) do
    moveAPI.pathTo( shaft[1], shaft[2], shaft[3], MAX_COST, nil, collisionCallBack )
    digShaft(mineShaftX, mineShaftY, mineShaftZ, MAX_COST )
    moveAPI.pathTo( mineShaftX, mineShaftY, mineShaftZ, MAX_COST, nil, collisionCallBack )

    for i = 1,16 do
        turtle.select(i)
        turtle.dropUp()
    end
    turtle.select(1)
end
